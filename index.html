<script>
  // ---- Postcode + distance helpers ----
  const pcCache = new Map(JSON.parse(localStorage.getItem("pcCache") || "[]"));
  const saveCache = () => localStorage.setItem("pcCache", JSON.stringify([...pcCache]));

  const normalisePC = pc =>
    pc.trim().toUpperCase().replace(/\s+/g, "").replace(/^([A-Z]{1,2}\d[A-Z\d]?\d[A-Z]{2})$/, (_, g)=> {
      // put the space back before the incode (last 3 chars)
      return g.slice(0, g.length - 3) + " " + g.slice(-3);
    });

  async function geocode(postcode) {
    const pc = normalisePC(postcode);
    if (pcCache.has(pc)) return pcCache.get(pc);
    const res = await fetch(`https://api.postcodes.io/postcodes/${encodeURIComponent(pc)}`);
    const data = await res.json();
    if (data.status !== 200 || !data.result) throw new Error("Geocode failed for " + pc);
    const ll = { lat: data.result.latitude, lon: data.result.longitude, pc };
    pcCache.set(pc, ll); saveCache();
    return ll;
  }

  function haversineKm(a, b) {
    const R = 6371, toRad = d => d * Math.PI / 180;
    const dLat = toRad(b.lat - a.lat);
    const dLon = toRad(b.lon - a.lon);
    const la1 = toRad(a.lat), la2 = toRad(b.lat);
    const h = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
    return 2 * R * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
  }

  async function osrmDrivingKm(a, b) {
    const url = `https://router.project-osrm.org/route/v1/driving/${a.lon},${a.lat};${b.lon},${b.lat}?overview=false`;
    const res = await fetch(url);
    const data = await res.json();
    if (!data || data.code !== "Ok" || !data.routes?.length) throw new Error("OSRM failed");
    return data.routes[0].distance / 1000; // metres -> km
  }

  async function bestDistanceKm(fromPc, toPc) {
    const [A, B] = await Promise.all([geocode(fromPc), geocode(toPc)]);
    try { return await osrmDrivingKm(A, B); }
    catch { return haversineKm(A, B); } // graceful fallback
  }

  // simple concurrency limiter so we donâ€™t hammer OSRM
  function pLimit(n) {
    let active = 0, q = [];
    const next = () => {
      if (active >= n || q.length === 0) return;
      active++;
      const {fn, resolve, reject} = q.shift();
      fn().then(resolve, reject).finally(() => { active--; next(); });
    };
    return fn => new Promise((resolve, reject) => { q.push({fn, resolve, reject}); next(); });
  }
  const limit5 = pLimit(5);

  // ---- Use it in your findSuppliers() ----
  async function findSuppliers() {
    const customerPostcode = document.getElementById('postcode').value.trim();
    const selectedServices = getSelectedServices();
    const resultsDiv = document.getElementById('results');

    if (!customerPostcode) { resultsDiv.innerHTML = '<div class="no-results">Please enter a customer postcode</div>'; return; }
    if (selectedServices.length === 0) { resultsDiv.innerHTML = '<div class="no-results">Please select at least one service</div>'; return; }

    resultsDiv.innerHTML = '<div class="loading">ğŸ” Calculating driving distancesâ€¦</div>';

    const matchingSuppliers = suppliers.filter(s => selectedServices.every(sv => s.services.includes(sv)));
    if (!matchingSuppliers.length) { resultsDiv.innerHTML = '<div class="no-results">No suppliers found that can provide all selected services</div>'; return; }

    // compute distances with a small concurrency cap
    const enriched = await Promise.all(matchingSuppliers.map(s => 
      limit5(() => bestDistanceKm(customerPostcode, s.postcode)
        .then(km => ({...s, distance: km}))
        .catch(() => ({...s, distance: Infinity}))
      )
    ));

    const sorted = enriched.filter(s => isFinite(s.distance)).sort((a,b)=>a.distance-b.distance);

    let html = `<p><strong>Found ${sorted.length} supplier(s) for services: ${selectedServices.join(', ')}</strong></p>`;
    sorted.forEach((s,i) => { html += `
      <div class="supplier-card">
        <div class="supplier-name">${i+1}. ${s.name}</div>
        <div class="supplier-details">
          ğŸ“ <strong>Postcode:</strong> ${s.postcode} |
          ğŸ“ <strong>Driving distance:</strong> <span class="distance">${s.distance.toFixed(1)} km</span><br>
          ğŸ“ <strong>Phone:</strong> ${s.phone} | ğŸ“§ <strong>Email:</strong> ${s.email}<br>
          ğŸ› ï¸ <strong>Services:</strong> ${s.services.join(', ')}
        </div>
      </div>`; 
    });
    resultsDiv.innerHTML = html || '<div class="no-results">Couldnâ€™t compute distances. Try again.</div>';
  }
</script>
